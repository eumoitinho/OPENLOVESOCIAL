[
  {
    "schemaname": "public",
    "functionname": "calculate_distance",
    "definition": "\r\nDECLARE\r\n    R DECIMAL := 6371; -- Raio da Terra em km\r\n    dlat DECIMAL;\r\n    dlon DECIMAL;\r\n    a DECIMAL;\r\n    c DECIMAL;\r\nBEGIN\r\n    dlat := radians(lat2 - lat1);\r\n    dlon := radians(lon2 - lon1);\r\n    a := sin(dlat/2) * sin(dlat/2) + \r\n         cos(radians(lat1)) * cos(radians(lat2)) * \r\n         sin(dlon/2) * sin(dlon/2);\r\n    c := 2 * atan2(sqrt(a), sqrt(1-a));\r\n    RETURN R * c;\r\nEND;\r\n"
  },
  {
    "schemaname": "pgbouncer",
    "functionname": "get_auth",
    "definition": "\nbegin\n    raise debug 'PgBouncer auth request: %', p_usename;\n\n    return query\n    select \n        rolname::text, \n        case when rolvaliduntil < now() \n            then null \n            else rolpassword::text \n        end \n    from pg_authid \n    where rolname=$1 and rolcanlogin;\nend;\n"
  },
  {
    "schemaname": "public",
    "functionname": "get_recommended_cards",
    "definition": "\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH user_prefs AS (\r\n        SELECT \r\n            age_min, age_max, distance_max, gender_preference,\r\n            relationship_type_preference, interests_preference\r\n        FROM open_dates_preferences \r\n        WHERE user_id = p_user_id\r\n    ),\r\n    user_profile AS (\r\n        SELECT \r\n            p.id, p.age, p.gender, p.interests, p.latitude, p.longitude,\r\n            p.relationship_status, p.profile_type\r\n        FROM profiles p \r\n        WHERE p.id = p_user_id\r\n    ),\r\n    candidate_cards AS (\r\n        SELECT \r\n            c.id as card_id,\r\n            c.user_id,\r\n            c.title,\r\n            c.subtitle,\r\n            c.description,\r\n            c.image_url,\r\n            c.icon,\r\n            c.colors,\r\n            p.age,\r\n            p.gender,\r\n            p.interests,\r\n            p.relationship_status,\r\n            p.profile_type,\r\n            p.latitude,\r\n            p.longitude,\r\n            up.latitude as user_lat,\r\n            up.longitude as user_lon\r\n        FROM open_dates_cards c\r\n        JOIN profiles p ON c.user_id = p.id\r\n        CROSS JOIN user_profile up\r\n        WHERE c.is_active = TRUE \r\n        AND c.user_id != p_user_id\r\n        AND NOT EXISTS (\r\n            SELECT 1 FROM open_dates_interactions oi \r\n            WHERE oi.viewer_id = p_user_id AND oi.card_id = c.id\r\n        )\r\n    )\r\n    SELECT \r\n        cc.card_id,\r\n        cc.user_id,\r\n        cc.title,\r\n        cc.subtitle,\r\n        cc.description,\r\n        cc.image_url,\r\n        cc.icon,\r\n        cc.colors,\r\n        CASE \r\n            WHEN cc.latitude IS NOT NULL AND cc.longitude IS NOT NULL \r\n            AND cc.user_lat IS NOT NULL AND cc.user_lon IS NOT NULL\r\n            THEN calculate_distance(cc.user_lat, cc.user_lon, cc.latitude, cc.longitude)\r\n            ELSE NULL\r\n        END as distance,\r\n        cc.age,\r\n        CASE \r\n            WHEN cc.interests IS NOT NULL AND up.interests IS NOT NULL\r\n            THEN array(\r\n                SELECT unnest(cc.interests) \r\n                INTERSECT \r\n                SELECT unnest(up.interests)\r\n            )\r\n            ELSE '{}'::TEXT[]\r\n        END as common_interests\r\n    FROM candidate_cards cc\r\n    CROSS JOIN user_prefs up\r\n    CROSS JOIN user_profile up2\r\n    WHERE \r\n        -- Filtros de idade\r\n        (cc.age IS NULL OR (cc.age >= up.age_min AND cc.age <= up.age_max))\r\n        -- Filtros de distância\r\n        AND (up.distance_max IS NULL OR cc.distance IS NULL OR cc.distance <= up.distance_max)\r\n        -- Filtros de gênero (se especificado)\r\n        AND (up.gender_preference = '{}' OR cc.gender = ANY(up.gender_preference))\r\n        -- Filtros de tipo de relacionamento (se especificado)\r\n        AND (up.relationship_type_preference = '{}' OR cc.profile_type = ANY(up.relationship_type_preference))\r\n    ORDER BY \r\n        -- Priorizar por interesses em comum\r\n        array_length(\r\n            CASE \r\n                WHEN cc.interests IS NOT NULL AND up2.interests IS NOT NULL\r\n                THEN array(\r\n                    SELECT unnest(cc.interests) \r\n                    INTERSECT \r\n                    SELECT unnest(up2.interests)\r\n                )\r\n                ELSE '{}'::TEXT[]\r\n            END, 1\r\n        ) DESC,\r\n        -- Depois por proximidade\r\n        cc.distance ASC NULLS LAST,\r\n        -- Por fim, por data de criação\r\n        cc.card_id DESC\r\n    LIMIT p_limit;\r\nEND;\r\n"
  },
  {
    "schemaname": "public",
    "functionname": "register_open_dates_interaction",
    "definition": "\r\nDECLARE\r\n    card_user_id UUID;\r\n    existing_match UUID;\r\nBEGIN\r\n    -- Verificar se a ação é válida\r\n    IF p_action NOT IN ('like', 'pass', 'super_like') THEN\r\n        RAISE EXCEPTION 'Invalid action: %', p_action;\r\n    END IF;\r\n    \r\n    -- Obter o usuário do card\r\n    SELECT user_id INTO card_user_id \r\n    FROM open_dates_cards \r\n    WHERE id = p_card_id;\r\n    \r\n    IF NOT FOUND THEN\r\n        RETURN FALSE;\r\n    END IF;\r\n    \r\n    -- Verificar se já existe interação\r\n    IF EXISTS (\r\n        SELECT 1 FROM open_dates_interactions \r\n        WHERE viewer_id = p_viewer_id AND card_id = p_card_id\r\n    ) THEN\r\n        RETURN FALSE;\r\n    END IF;\r\n    \r\n    -- Registrar a interação\r\n    INSERT INTO open_dates_interactions (viewer_id, card_id, action)\r\n    VALUES (p_viewer_id, p_card_id, p_action);\r\n    \r\n    -- Se for like ou super_like, verificar se há match\r\n    IF p_action IN ('like', 'super_like') THEN\r\n        -- Verificar se o outro usuário também deu like\r\n        IF EXISTS (\r\n            SELECT 1 FROM open_dates_interactions oi\r\n            JOIN open_dates_cards c ON oi.card_id = c.id\r\n            WHERE oi.viewer_id = card_user_id \r\n            AND c.user_id = p_viewer_id\r\n            AND oi.action IN ('like', 'super_like')\r\n        ) THEN\r\n            -- Criar match\r\n            INSERT INTO open_dates_matches (user1_id, user2_id)\r\n            VALUES (\r\n                LEAST(p_viewer_id, card_user_id),\r\n                GREATEST(p_viewer_id, card_user_id)\r\n            )\r\n            ON CONFLICT (user1_id, user2_id) DO NOTHING;\r\n        END IF;\r\n        \r\n        -- Atualizar contador de likes do card\r\n        UPDATE open_dates_cards \r\n        SET likes_count = likes_count + 1\r\n        WHERE id = p_card_id;\r\n    END IF;\r\n    \r\n    RETURN TRUE;\r\nEND;\r\n"
  },
  {
    "schemaname": "public",
    "functionname": "get_user_matches",
    "definition": "\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT \r\n        m.id as match_id,\r\n        CASE \r\n            WHEN m.user1_id = p_user_id THEN m.user2_id\r\n            ELSE m.user1_id\r\n        END as other_user_id,\r\n        p.full_name as other_user_name,\r\n        p.avatar_url as other_user_avatar,\r\n        m.matched_at,\r\n        last_msg.last_message_at,\r\n        COALESCE(unread.unread_count, 0) as unread_count\r\n    FROM open_dates_matches m\r\n    JOIN profiles p ON p.id = CASE \r\n        WHEN m.user1_id = p_user_id THEN m.user2_id\r\n        ELSE m.user1_id\r\n    END\r\n    LEFT JOIN (\r\n        SELECT \r\n            match_id,\r\n            MAX(created_at) as last_message_at\r\n        FROM open_dates_messages\r\n        GROUP BY match_id\r\n    ) last_msg ON last_msg.match_id = m.id\r\n    LEFT JOIN (\r\n        SELECT \r\n            match_id,\r\n            COUNT(*) as unread_count\r\n        FROM open_dates_messages\r\n        WHERE sender_id != p_user_id AND is_read = FALSE\r\n        GROUP BY match_id\r\n    ) unread ON unread.match_id = m.id\r\n    WHERE m.is_active = TRUE \r\n    AND (m.user1_id = p_user_id OR m.user2_id = p_user_id)\r\n    ORDER BY last_msg.last_message_at DESC NULLS LAST, m.matched_at DESC;\r\nEND;\r\n"
  },
  {
    "schemaname": "extensions",
    "functionname": "gen_salt",
    "definition": "pg_gen_salt"
  },
  {
    "schemaname": "extensions",
    "functionname": "encrypt",
    "definition": "pg_encrypt"
  },
  {
    "schemaname": "extensions",
    "functionname": "decrypt",
    "definition": "pg_decrypt"
  },
  {
    "schemaname": "extensions",
    "functionname": "pg_stat_statements_info",
    "definition": "pg_stat_statements_info"
  },
  {
    "schemaname": "extensions",
    "functionname": "gen_salt",
    "definition": "pg_gen_salt_rounds"
  },
  {
    "schemaname": "public",
    "functionname": "update_open_dates_updated_at",
    "definition": "\r\nBEGIN\r\n    NEW.updated_at = NOW();\r\n    RETURN NEW;\r\nEND;\r\n"
  },
  {
    "schemaname": "extensions",
    "functionname": "pg_stat_statements_reset",
    "definition": "pg_stat_statements_reset_1_11"
  },
  {
    "schemaname": "extensions",
    "functionname": "uuid_nil",
    "definition": "uuid_nil"
  },
  {
    "schemaname": "extensions",
    "functionname": "uuid_ns_dns",
    "definition": "uuid_ns_dns"
  },
  {
    "schemaname": "extensions",
    "functionname": "uuid_ns_url",
    "definition": "uuid_ns_url"
  },
  {
    "schemaname": "extensions",
    "functionname": "uuid_ns_oid",
    "definition": "uuid_ns_oid"
  },
  {
    "schemaname": "auth",
    "functionname": "email",
    "definition": "\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n"
  },
  {
    "schemaname": "extensions",
    "functionname": "uuid_ns_x500",
    "definition": "uuid_ns_x500"
  },
  {
    "schemaname": "extensions",
    "functionname": "uuid_generate_v1",
    "definition": "uuid_generate_v1"
  },
  {
    "schemaname": "auth",
    "functionname": "uid",
    "definition": "\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.sub', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')\n  )::uuid\n"
  },
  {
    "schemaname": "auth",
    "functionname": "role",
    "definition": "\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n"
  },
  {
    "schemaname": "public",
    "functionname": "insert_user_with_auth",
    "definition": "\r\nDECLARE\r\n    user_id UUID;\r\n    seeking_array TEXT[] := '{}';\r\n    interests_array TEXT[] := '{}';\r\nBEGIN\r\n    -- Converter arrays de forma segura\r\n    IF user_data ? 'seeking' AND user_data->'seeking' IS NOT NULL AND user_data->'seeking' != '[]'::jsonb THEN\r\n        SELECT ARRAY_AGG(value::text) INTO seeking_array\r\n        FROM jsonb_array_elements_text(user_data->'seeking');\r\n    END IF;\r\n    \r\n    IF user_data ? 'interests' AND user_data->'interests' IS NOT NULL AND user_data->'interests' != '[]'::jsonb THEN\r\n        SELECT ARRAY_AGG(value::text) INTO interests_array\r\n        FROM jsonb_array_elements_text(user_data->'interests');\r\n    END IF;\r\n    \r\n    -- Inserir na tabela users\r\n    INSERT INTO users (\r\n        id,\r\n        email,\r\n        username,\r\n        name,\r\n        first_name,\r\n        last_name,\r\n        birth_date,\r\n        profile_type,\r\n        seeking,\r\n        interests,\r\n        other_interest,\r\n        bio,\r\n        location,\r\n        uf,\r\n        latitude,\r\n        longitude,\r\n        plano,\r\n        status_assinatura,\r\n        created_at,\r\n        updated_at,\r\n        partner\r\n    ) VALUES (\r\n        (user_data->>'id')::UUID,\r\n        user_data->>'email',\r\n        user_data->>'username',\r\n        user_data->>'name',\r\n        user_data->>'first_name',\r\n        user_data->>'last_name',\r\n        CASE \r\n            WHEN user_data->>'birth_date' IS NOT NULL AND user_data->>'birth_date' != '' \r\n            THEN (user_data->>'birth_date')::DATE \r\n            ELSE NULL \r\n        END,\r\n        user_data->>'profile_type',\r\n        seeking_array,\r\n        interests_array,\r\n        user_data->>'other_interest',\r\n        user_data->>'bio',\r\n        user_data->>'location',\r\n        CASE \r\n            WHEN user_data->>'uf' IS NOT NULL AND user_data->>'uf' != '' \r\n            THEN LEFT(user_data->>'uf', 2) \r\n            ELSE NULL \r\n        END,\r\n        CASE \r\n            WHEN user_data->>'latitude' IS NOT NULL AND user_data->>'latitude' != '' \r\n            THEN (user_data->>'latitude')::DECIMAL \r\n            ELSE NULL \r\n        END,\r\n        CASE \r\n            WHEN user_data->>'longitude' IS NOT NULL AND user_data->>'longitude' != '' \r\n            THEN (user_data->>'longitude')::DECIMAL \r\n            ELSE NULL \r\n        END,\r\n        user_data->>'plano',\r\n        user_data->>'status_assinatura',\r\n        NOW(),\r\n        NOW(),\r\n        user_data->'partner'\r\n    ) RETURNING id INTO user_id;\r\n    \r\n    RETURN user_id;\r\nEND;\r\n"
  },
  {
    "schemaname": "extensions",
    "functionname": "uuid_generate_v1mc",
    "definition": "uuid_generate_v1mc"
  },
  {
    "schemaname": "extensions",
    "functionname": "uuid_generate_v3",
    "definition": "uuid_generate_v3"
  },
  {
    "schemaname": "extensions",
    "functionname": "uuid_generate_v4",
    "definition": "uuid_generate_v4"
  },
  {
    "schemaname": "extensions",
    "functionname": "uuid_generate_v5",
    "definition": "uuid_generate_v5"
  },
  {
    "schemaname": "extensions",
    "functionname": "digest",
    "definition": "pg_digest"
  },
  {
    "schemaname": "extensions",
    "functionname": "digest",
    "definition": "pg_digest"
  },
  {
    "schemaname": "extensions",
    "functionname": "hmac",
    "definition": "pg_hmac"
  },
  {
    "schemaname": "extensions",
    "functionname": "hmac",
    "definition": "pg_hmac"
  },
  {
    "schemaname": "extensions",
    "functionname": "crypt",
    "definition": "pg_crypt"
  },
  {
    "schemaname": "extensions",
    "functionname": "encrypt_iv",
    "definition": "pg_encrypt_iv"
  },
  {
    "schemaname": "extensions",
    "functionname": "decrypt_iv",
    "definition": "pg_decrypt_iv"
  },
  {
    "schemaname": "extensions",
    "functionname": "gen_random_bytes",
    "definition": "pg_random_bytes"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_pub_decrypt",
    "definition": "pgp_pub_decrypt_text"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_pub_decrypt_bytea",
    "definition": "pgp_pub_decrypt_bytea"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_pub_decrypt",
    "definition": "pgp_pub_decrypt_text"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_pub_decrypt_bytea",
    "definition": "pgp_pub_decrypt_bytea"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_key_id",
    "definition": "pgp_key_id_w"
  },
  {
    "schemaname": "extensions",
    "functionname": "armor",
    "definition": "pg_armor"
  },
  {
    "schemaname": "extensions",
    "functionname": "armor",
    "definition": "pg_armor"
  },
  {
    "schemaname": "extensions",
    "functionname": "dearmor",
    "definition": "pg_dearmor"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_armor_headers",
    "definition": "pgp_armor_headers"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgrst_ddl_watch",
    "definition": "\nDECLARE\n  cmd record;\nBEGIN\n  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()\n  LOOP\n    IF cmd.command_tag IN (\n      'CREATE SCHEMA', 'ALTER SCHEMA'\n    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'\n    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'\n    , 'CREATE VIEW', 'ALTER VIEW'\n    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'\n    , 'CREATE FUNCTION', 'ALTER FUNCTION'\n    , 'CREATE TRIGGER'\n    , 'CREATE TYPE', 'ALTER TYPE'\n    , 'CREATE RULE'\n    , 'COMMENT'\n    )\n    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp\n    AND cmd.schema_name is distinct from 'pg_temp'\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; "
  },
  {
    "schemaname": "extensions",
    "functionname": "grant_pg_graphql_access",
    "definition": "\nDECLARE\n    func_is_graphql_resolve bool;\nBEGIN\n    func_is_graphql_resolve = (\n        SELECT n.proname = 'resolve'\n        FROM pg_event_trigger_ddl_commands() AS ev\n        LEFT JOIN pg_catalog.pg_proc AS n\n        ON ev.objid = n.oid\n    );\n\n    IF func_is_graphql_resolve\n    THEN\n        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func\n        DROP FUNCTION IF EXISTS graphql_public.graphql;\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language sql\n        as $$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $$;\n\n        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last\n        -- function in the extension so we need to grant permissions on existing entities AND\n        -- update default permissions to any others that are created after `graphql.resolve`\n        grant usage on schema graphql to postgres, anon, authenticated, service_role;\n        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;\n        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;\n        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;\n\n        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles\n        grant usage on schema graphql_public to postgres with grant option;\n        grant usage on schema graphql to postgres with grant option;\n    END IF;\n\nEND;\n"
  },
  {
    "schemaname": "graphql",
    "functionname": "get_schema_version",
    "definition": "\n    select last_value from graphql.seq_schema_version;\n"
  },
  {
    "schemaname": "graphql",
    "functionname": "comment_directive",
    "definition": "\n    /*\n    comment on column public.account.name is '@graphql.name: myField'\n    */\n    select\n        coalesce(\n            (\n                regexp_match(\n                    comment_,\n                    '@graphql\\((.+)\\)'\n                )\n            )[1]::jsonb,\n            jsonb_build_object()\n        )\n"
  },
  {
    "schemaname": "graphql",
    "functionname": "_internal_resolve",
    "definition": "resolve_wrapper"
  },
  {
    "schemaname": "graphql",
    "functionname": "resolve",
    "definition": "\ndeclare\n    res jsonb;\n    message_text text;\nbegin\n  begin\n    select graphql._internal_resolve(\"query\" := \"query\",\n                                     \"variables\" := \"variables\",\n                                     \"operationName\" := \"operationName\",\n                                     \"extensions\" := \"extensions\") into res;\n    return res;\n  exception\n    when others then\n    get stacked diagnostics message_text = message_text;\n    return\n    jsonb_build_object('data', null,\n                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));\n  end;\nend;\n"
  },
  {
    "schemaname": "vault",
    "functionname": "_crypto_aead_det_encrypt",
    "definition": "pgsodium_crypto_aead_det_encrypt_by_id"
  },
  {
    "schemaname": "vault",
    "functionname": "_crypto_aead_det_noncegen",
    "definition": "pgsodium_crypto_aead_det_noncegen"
  },
  {
    "schemaname": "storage",
    "functionname": "operation",
    "definition": "\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n"
  },
  {
    "schemaname": "vault",
    "functionname": "create_secret",
    "definition": "\nDECLARE\n  rec record;\nBEGIN\n  INSERT INTO vault.secrets (secret, name, description)\n  VALUES (\n    new_secret,\n    new_name,\n    new_description\n  )\n  RETURNING * INTO rec;\n  UPDATE vault.secrets s\n  SET secret = encode(vault._crypto_aead_det_encrypt(\n    message := convert_to(rec.secret, 'utf8'),\n    additional := convert_to(s.id::text, 'utf8'),\n    key_id := 0,\n    context := 'pgsodium'::bytea,\n    nonce := rec.nonce\n  ), 'base64')\n  WHERE id = rec.id;\n  RETURN rec.id;\nEND\n"
  },
  {
    "schemaname": "vault",
    "functionname": "update_secret",
    "definition": "\nDECLARE\n  decrypted_secret text := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE id = secret_id);\nBEGIN\n  UPDATE vault.secrets s\n  SET\n    secret = CASE WHEN new_secret IS NULL THEN s.secret\n                  ELSE encode(vault._crypto_aead_det_encrypt(\n                    message := convert_to(new_secret, 'utf8'),\n                    additional := convert_to(s.id::text, 'utf8'),\n                    key_id := 0,\n                    context := 'pgsodium'::bytea,\n                    nonce := s.nonce\n                  ), 'base64') END,\n    name = coalesce(new_name, s.name),\n    description = coalesce(new_description, s.description),\n    updated_at = now()\n  WHERE s.id = secret_id;\nEND\n"
  },
  {
    "schemaname": "vault",
    "functionname": "_crypto_aead_det_decrypt",
    "definition": "pgsodium_crypto_aead_det_decrypt_by_id"
  },
  {
    "schemaname": "extensions",
    "functionname": "gen_random_uuid",
    "definition": "pg_random_uuid"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_sym_encrypt",
    "definition": "pgp_sym_encrypt_text"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_sym_encrypt_bytea",
    "definition": "pgp_sym_encrypt_bytea"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_sym_encrypt",
    "definition": "pgp_sym_encrypt_text"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_sym_encrypt_bytea",
    "definition": "pgp_sym_encrypt_bytea"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_sym_decrypt",
    "definition": "pgp_sym_decrypt_text"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_sym_decrypt_bytea",
    "definition": "pgp_sym_decrypt_bytea"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_sym_decrypt",
    "definition": "pgp_sym_decrypt_text"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_sym_decrypt_bytea",
    "definition": "pgp_sym_decrypt_bytea"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_pub_encrypt",
    "definition": "pgp_pub_encrypt_text"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_pub_encrypt_bytea",
    "definition": "pgp_pub_encrypt_bytea"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_pub_encrypt",
    "definition": "pgp_pub_encrypt_text"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_pub_encrypt_bytea",
    "definition": "pgp_pub_encrypt_bytea"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_pub_decrypt",
    "definition": "pgp_pub_decrypt_text"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgp_pub_decrypt_bytea",
    "definition": "pgp_pub_decrypt_bytea"
  },
  {
    "schemaname": "extensions",
    "functionname": "pg_stat_statements",
    "definition": "pg_stat_statements_1_11"
  },
  {
    "schemaname": "extensions",
    "functionname": "pgrst_drop_watch",
    "definition": "\nDECLARE\n  obj record;\nBEGIN\n  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n  LOOP\n    IF obj.object_type IN (\n      'schema'\n    , 'table'\n    , 'foreign table'\n    , 'view'\n    , 'materialized view'\n    , 'function'\n    , 'trigger'\n    , 'type'\n    , 'rule'\n    )\n    AND obj.is_temporary IS false -- no pg_temp objects\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; "
  },
  {
    "schemaname": "extensions",
    "functionname": "set_graphql_placeholder",
    "definition": "\n    DECLARE\n    graphql_is_dropped bool;\n    BEGIN\n    graphql_is_dropped = (\n        SELECT ev.schema_name = 'graphql_public'\n        FROM pg_event_trigger_dropped_objects() AS ev\n        WHERE ev.schema_name = 'graphql_public'\n    );\n\n    IF graphql_is_dropped\n    THEN\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language plpgsql\n        as $$\n            DECLARE\n                server_version float;\n            BEGIN\n                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);\n\n                IF server_version >= 14 THEN\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql extension is not enabled.'\n                            )\n                        )\n                    );\n                ELSE\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'\n                            )\n                        )\n                    );\n                END IF;\n            END;\n        $$;\n    END IF;\n\n    END;\n"
  },
  {
    "schemaname": "extensions",
    "functionname": "grant_pg_net_access",
    "definition": "\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_net'\n  )\n  THEN\n    IF NOT EXISTS (\n      SELECT 1\n      FROM pg_roles\n      WHERE rolname = 'supabase_functions_admin'\n    )\n    THEN\n      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;\n    END IF;\n\n    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n\n    IF EXISTS (\n      SELECT FROM pg_extension\n      WHERE extname = 'pg_net'\n      -- all versions in use on existing projects as of 2025-02-20\n      -- version 0.12.0 onwards don't need these applied\n      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')\n    ) THEN\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n\n      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n\n      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n    END IF;\n  END IF;\nEND;\n"
  },
  {
    "schemaname": "graphql_public",
    "functionname": "graphql",
    "definition": "\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        "
  },
  {
    "schemaname": "graphql",
    "functionname": "exception",
    "definition": "\nbegin\n    raise exception using errcode='22000', message=message;\nend;\n"
  },
  {
    "schemaname": "graphql",
    "functionname": "increment_schema_version",
    "definition": "\nbegin\n    perform pg_catalog.nextval('graphql.seq_schema_version');\nend;\n"
  },
  {
    "schemaname": "extensions",
    "functionname": "grant_pg_cron_access",
    "definition": "\nBEGIN\n  IF EXISTS (\n    SELECT\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_cron'\n  )\n  THEN\n    grant usage on schema cron to postgres with grant option;\n\n    alter default privileges in schema cron grant all on tables to postgres with grant option;\n    alter default privileges in schema cron grant all on functions to postgres with grant option;\n    alter default privileges in schema cron grant all on sequences to postgres with grant option;\n\n    alter default privileges for user supabase_admin in schema cron grant all\n        on sequences to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on tables to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on functions to postgres with grant option;\n\n    grant all privileges on all tables in schema cron to postgres with grant option;\n    revoke all on table cron.job from postgres;\n    grant select on table cron.job to postgres with grant option;\n  END IF;\nEND;\n"
  },
  {
    "schemaname": "storage",
    "functionname": "foldername",
    "definition": "\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[1:array_length(_parts,1)-1];\nEND\n"
  },
  {
    "schemaname": "storage",
    "functionname": "filename",
    "definition": "\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n"
  },
  {
    "schemaname": "storage",
    "functionname": "extension",
    "definition": "\nDECLARE\n_parts text[];\n_filename text;\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\tselect _parts[array_length(_parts,1)] into _filename;\n\t-- @todo return the last part instead of 2\n\treturn reverse(split_part(reverse(_filename), '.', 1));\nEND\n"
  },
  {
    "schemaname": "storage",
    "functionname": "get_size_by_bucket",
    "definition": "\nBEGIN\n    return query\n        select sum((metadata->>'size')::int) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n"
  },
  {
    "schemaname": "realtime",
    "functionname": "cast",
    "definition": "\n    declare\n      res jsonb;\n    begin\n      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;\n      return res;\n    end\n    "
  },
  {
    "schemaname": "realtime",
    "functionname": "check_equality_op",
    "definition": "\n      /*\n      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness\n      */\n      declare\n          op_symbol text = (\n              case\n                  when op = 'eq' then '='\n                  when op = 'neq' then '!='\n                  when op = 'lt' then '<'\n                  when op = 'lte' then '<='\n                  when op = 'gt' then '>'\n                  when op = 'gte' then '>='\n                  when op = 'in' then '= any'\n                  else 'UNKNOWN OP'\n              end\n          );\n          res boolean;\n      begin\n          execute format(\n              'select %L::'|| type_::text || ' ' || op_symbol\n              || ' ( %L::'\n              || (\n                  case\n                      when op = 'in' then type_::text || '[]'\n                      else type_::text end\n              )\n              || ')', val_1, val_2) into res;\n          return res;\n      end;\n      "
  },
  {
    "schemaname": "storage",
    "functionname": "update_updated_at_column",
    "definition": "\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n"
  },
  {
    "schemaname": "storage",
    "functionname": "can_insert_object",
    "definition": "\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n"
  },
  {
    "schemaname": "storage",
    "functionname": "list_objects_with_delimiter",
    "definition": "\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(name COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))\n                    ELSE\n                        name\n                END AS name, id, metadata, updated_at\n            FROM\n                storage.objects\n            WHERE\n                bucket_id = $5 AND\n                name ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $6 != '''' THEN\n                    name COLLATE \"C\" > $6\n                ELSE true END\n                AND CASE\n                    WHEN $4 != '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                name COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END\n            ORDER BY\n                name COLLATE \"C\" ASC) as e order by name COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;\nEND;\n"
  },
  {
    "schemaname": "storage",
    "functionname": "list_multipart_uploads_with_delimiter",
    "definition": "\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE\n                bucket_id = $5 AND\n                key ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $4 != '''' AND $6 = '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                key COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END AND\n                CASE\n                    WHEN $6 != '''' THEN\n                        id COLLATE \"C\" > $6\n                    ELSE\n                        true\n                    END\n            ORDER BY\n                key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;\nEND;\n"
  },
  {
    "schemaname": "storage",
    "functionname": "search",
    "definition": "\ndeclare\n  v_order_by text;\n  v_sort_order text;\nbegin\n  case\n    when sortcolumn = 'name' then\n      v_order_by = 'name';\n    when sortcolumn = 'updated_at' then\n      v_order_by = 'updated_at';\n    when sortcolumn = 'created_at' then\n      v_order_by = 'created_at';\n    when sortcolumn = 'last_accessed_at' then\n      v_order_by = 'last_accessed_at';\n    else\n      v_order_by = 'name';\n  end case;\n\n  case\n    when sortorder = 'asc' then\n      v_sort_order = 'asc';\n    when sortorder = 'desc' then\n      v_sort_order = 'desc';\n    else\n      v_sort_order = 'asc';\n  end case;\n\n  v_order_by = v_order_by || ' ' || v_sort_order;\n\n  return query execute\n    'with folders as (\n       select path_tokens[$1] as folder\n       from storage.objects\n         where objects.name ilike $2 || $3 || ''%''\n           and bucket_id = $4\n           and array_length(objects.path_tokens, 1) <> $1\n       group by folder\n       order by folder ' || v_sort_order || '\n     )\n     (select folder as \"name\",\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[$1] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where objects.name ilike $2 || $3 || ''%''\n       and bucket_id = $4\n       and array_length(objects.path_tokens, 1) = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n"
  },
  {
    "schemaname": "realtime",
    "functionname": "broadcast_changes",
    "definition": "\nDECLARE\n    -- Declare a variable to hold the JSONB representation of the row\n    row_data jsonb := '{}'::jsonb;\nBEGIN\n    IF level = 'STATEMENT' THEN\n        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';\n    END IF;\n    -- Check the operation type and handle accordingly\n    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN\n        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);\n        PERFORM realtime.send (row_data, event_name, topic_name);\n    ELSE\n        RAISE EXCEPTION 'Unexpected operation type: %', operation;\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;\nEND;\n\n"
  },
  {
    "schemaname": "realtime",
    "functionname": "to_regrole",
    "definition": " select role_name::regrole "
  },
  {
    "schemaname": "realtime",
    "functionname": "build_prepared_statement_sql",
    "definition": "\n      /*\n      Builds a sql string that, if executed, creates a prepared statement to\n      tests retrive a row from *entity* by its primary key columns.\n      Example\n          select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])\n      */\n          select\n      'prepare ' || prepared_statement_name || ' as\n          select\n              exists(\n                  select\n                      1\n                  from\n                      ' || entity || '\n                  where\n                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '\n              )'\n          from\n              unnest(columns) pkc\n          where\n              pkc.is_pkey\n          group by\n              entity\n      "
  },
  {
    "schemaname": "realtime",
    "functionname": "apply_rls",
    "definition": "\ndeclare\n-- Regclass of the table e.g. public.notes\nentity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n-- I, U, D, T: insert, update ...\naction realtime.action = (\n    case wal ->> 'action'\n        when 'I' then 'INSERT'\n        when 'U' then 'UPDATE'\n        when 'D' then 'DELETE'\n        else 'ERROR'\n    end\n);\n\n-- Is row level security enabled for the table\nis_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\nsubscriptions realtime.subscription[] = array_agg(subs)\n    from\n        realtime.subscription subs\n    where\n        subs.entity = entity_;\n\n-- Subscription vars\nroles regrole[] = array_agg(distinct us.claims_role::text)\n    from\n        unnest(subscriptions) us;\n\nworking_role regrole;\nclaimed_role regrole;\nclaims jsonb;\n\nsubscription_id uuid;\nsubscription_has_access bool;\nvisible_to_subscription_ids uuid[] = '{}';\n\n-- structured info for wal's columns\ncolumns realtime.wal_column[];\n-- previous identity values for update/delete\nold_columns realtime.wal_column[];\n\nerror_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;\n\n-- Primary jsonb output for record\noutput jsonb;\n\nbegin\nperform set_config('role', null, true);\n\ncolumns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'columns') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nold_columns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'identity') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nfor working_role in select * from unnest(roles) loop\n\n    -- Update `is_selectable` for columns and old_columns\n    columns =\n        array_agg(\n            (\n                c.name,\n                c.type_name,\n                c.type_oid,\n                c.value,\n                c.is_pkey,\n                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n            )::realtime.wal_column\n        )\n        from\n            unnest(columns) c;\n\n    old_columns =\n            array_agg(\n                (\n                    c.name,\n                    c.type_name,\n                    c.type_oid,\n                    c.value,\n                    c.is_pkey,\n                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                )::realtime.wal_column\n            )\n            from\n                unnest(old_columns) c;\n\n    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            -- subscriptions is already filtered by entity\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 400: Bad Request, no primary key']\n        )::realtime.wal_rls;\n\n    -- The claims role does not have SELECT permission to the primary key of entity\n    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 401: Unauthorized']\n        )::realtime.wal_rls;\n\n    else\n        output = jsonb_build_object(\n            'schema', wal ->> 'schema',\n            'table', wal ->> 'table',\n            'type', action,\n            'commit_timestamp', to_char(\n                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),\n                'YYYY-MM-DD\"T\"HH24:MI:SS.MS\"Z\"'\n            ),\n            'columns', (\n                select\n                    jsonb_agg(\n                        jsonb_build_object(\n                            'name', pa.attname,\n                            'type', pt.typname\n                        )\n                        order by pa.attnum asc\n                    )\n                from\n                    pg_attribute pa\n                    join pg_type pt\n                        on pa.atttypid = pt.oid\n                where\n                    attrelid = entity_\n                    and attnum > 0\n                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')\n            )\n        )\n        -- Add \"record\" key for insert and update\n        || case\n            when action in ('INSERT', 'UPDATE') then\n                jsonb_build_object(\n                    'record',\n                    (\n                        select\n                            jsonb_object_agg(\n                                -- if unchanged toast, get column name and value from old record\n                                coalesce((c).name, (oc).name),\n                                case\n                                    when (c).name is null then (oc).value\n                                    else (c).value\n                                end\n                            )\n                        from\n                            unnest(columns) c\n                            full outer join unnest(old_columns) oc\n                                on (c).name = (oc).name\n                        where\n                            coalesce((c).is_selectable, (oc).is_selectable)\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                    )\n                )\n            else '{}'::jsonb\n        end\n        -- Add \"old_record\" key for update and delete\n        || case\n            when action = 'UPDATE' then\n                jsonb_build_object(\n                        'old_record',\n                        (\n                            select jsonb_object_agg((c).name, (c).value)\n                            from unnest(old_columns) c\n                            where\n                                (c).is_selectable\n                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                        )\n                    )\n            when action = 'DELETE' then\n                jsonb_build_object(\n                    'old_record',\n                    (\n                        select jsonb_object_agg((c).name, (c).value)\n                        from unnest(old_columns) c\n                        where\n                            (c).is_selectable\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey\n                    )\n                )\n            else '{}'::jsonb\n        end;\n\n        -- Create the prepared statement\n        if is_rls_enabled and action <> 'DELETE' then\n            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then\n                deallocate walrus_rls_stmt;\n            end if;\n            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);\n        end if;\n\n        visible_to_subscription_ids = '{}';\n\n        for subscription_id, claims in (\n                select\n                    subs.subscription_id,\n                    subs.claims\n                from\n                    unnest(subscriptions) subs\n                where\n                    subs.entity = entity_\n                    and subs.claims_role = working_role\n                    and (\n                        realtime.is_visible_through_filters(columns, subs.filters)\n                        or (\n                          action = 'DELETE'\n                          and realtime.is_visible_through_filters(old_columns, subs.filters)\n                        )\n                    )\n        ) loop\n\n            if not is_rls_enabled or action = 'DELETE' then\n                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n            else\n                -- Check if RLS allows the role to see the record\n                perform\n                    -- Trim leading and trailing quotes from working_role because set_config\n                    -- doesn't recognize the role as valid if they are included\n                    set_config('role', trim(both '\"' from working_role::text), true),\n                    set_config('request.jwt.claims', claims::text, true);\n\n                execute 'execute walrus_rls_stmt' into subscription_has_access;\n\n                if subscription_has_access then\n                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n                end if;\n            end if;\n        end loop;\n\n        perform set_config('role', null, true);\n\n        return next (\n            output,\n            is_rls_enabled,\n            visible_to_subscription_ids,\n            case\n                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']\n                else '{}'\n            end\n        )::realtime.wal_rls;\n\n    end if;\nend loop;\n\nperform set_config('role', null, true);\nend;\n"
  },
  {
    "schemaname": "realtime",
    "functionname": "quote_wal2json",
    "definition": "\n      select\n        (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n        )\n        || '.'\n        || (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n          )\n      from\n        pg_class pc\n        join pg_namespace nsp\n          on pc.relnamespace = nsp.oid\n      where\n        pc.oid = entity\n    "
  },
  {
    "schemaname": "realtime",
    "functionname": "list_changes",
    "definition": "\n      with pub as (\n        select\n          concat_ws(\n            ',',\n            case when bool_or(pubinsert) then 'insert' else null end,\n            case when bool_or(pubupdate) then 'update' else null end,\n            case when bool_or(pubdelete) then 'delete' else null end\n          ) as w2j_actions,\n          coalesce(\n            string_agg(\n              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),\n              ','\n            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),\n            ''\n          ) w2j_add_tables\n        from\n          pg_publication pp\n          left join pg_publication_tables ppt\n            on pp.pubname = ppt.pubname\n        where\n          pp.pubname = publication\n        group by\n          pp.pubname\n        limit 1\n      ),\n      w2j as (\n        select\n          x.*, pub.w2j_add_tables\n        from\n          pub,\n          pg_logical_slot_get_changes(\n            slot_name, null, max_changes,\n            'include-pk', 'true',\n            'include-transaction', 'false',\n            'include-timestamp', 'true',\n            'include-type-oids', 'true',\n            'format-version', '2',\n            'actions', pub.w2j_actions,\n            'add-tables', pub.w2j_add_tables\n          ) x\n      )\n      select\n        xyz.wal,\n        xyz.is_rls_enabled,\n        xyz.subscription_ids,\n        xyz.errors\n      from\n        w2j,\n        realtime.apply_rls(\n          wal := w2j.data::jsonb,\n          max_record_bytes := max_record_bytes\n        ) xyz(wal, is_rls_enabled, subscription_ids, errors)\n      where\n        w2j.w2j_add_tables <> ''\n        and xyz.subscription_ids[1] is not null\n    "
  },
  {
    "schemaname": "realtime",
    "functionname": "subscription_check_filters",
    "definition": "\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity\n                and pg_catalog.has_column_privilege(\n                    (new.claims ->> 'role'),\n                    format('%I.%I', c.table_schema, c.table_name)::regclass,\n                    c.column_name,\n                    'SELECT'\n                );\n        filter realtime.user_defined_filter;\n        col_type regtype;\n\n        in_val jsonb;\n    begin\n        for filter in select * from unnest(new.filters) loop\n            -- Filtered column is valid\n            if not filter.column_name = any(col_names) then\n                raise exception 'invalid column for filter %', filter.column_name;\n            end if;\n\n            -- Type is sanitized and safe for string interpolation\n            col_type = (\n                select atttypid::regtype\n                from pg_catalog.pg_attribute\n                where attrelid = new.entity\n                      and attname = filter.column_name\n            );\n            if col_type is null then\n                raise exception 'failed to lookup type for column %', filter.column_name;\n            end if;\n\n            -- Set maximum number of entries for in filter\n            if filter.op = 'in'::realtime.equality_op then\n                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);\n                if coalesce(jsonb_array_length(in_val), 0) > 100 then\n                    raise exception 'too many values for `in` filter. Maximum 100';\n                end if;\n            else\n                -- raises an exception if value is not coercable to type\n                perform realtime.cast(filter.value, col_type);\n            end if;\n\n        end loop;\n\n        -- Apply consistent order to filters so the unique constraint on\n        -- (subscription_id, entity, filters) can't be tricked by a different filter order\n        new.filters = coalesce(\n            array_agg(f order by f.column_name, f.op, f.value),\n            '{}'\n        ) from unnest(new.filters) f;\n\n        return new;\n    end;\n    "
  },
  {
    "schemaname": "realtime",
    "functionname": "is_visible_through_filters",
    "definition": "\n    /*\n    Should the record be visible (true) or filtered out (false) after *filters* are applied\n    */\n        select\n            -- Default to allowed when no filters present\n            $2 is null -- no filters. this should not happen because subscriptions has a default\n            or array_length($2, 1) is null -- array length of an empty array is null\n            or bool_and(\n                coalesce(\n                    realtime.check_equality_op(\n                        op:=f.op,\n                        type_:=coalesce(\n                            col.type_oid::regtype, -- null when wal2json version <= 2.4\n                            col.type_name::regtype\n                        ),\n                        -- cast jsonb to text\n                        val_1:=col.value #>> '{}',\n                        val_2:=f.value\n                    ),\n                    false -- if null, filter does not match\n                )\n            )\n        from\n            unnest(filters) f\n            join unnest(columns) col\n                on f.column_name = col.name;\n    "
  },
  {
    "schemaname": "realtime",
    "functionname": "topic",
    "definition": "\nselect nullif(current_setting('realtime.topic', true), '')::text;\n"
  },
  {
    "schemaname": "realtime",
    "functionname": "send",
    "definition": "\nBEGIN\n  BEGIN\n    -- Set the topic configuration\n    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);\n\n    -- Attempt to insert the message\n    INSERT INTO realtime.messages (payload, event, topic, private, extension)\n    VALUES (payload, event, topic, private, 'broadcast');\n  EXCEPTION\n    WHEN OTHERS THEN\n      -- Capture and notify the error\n      PERFORM pg_notify(\n          'realtime:system',\n          jsonb_build_object(\n              'error', SQLERRM,\n              'function', 'realtime.send',\n              'event', event,\n              'topic', topic,\n              'private', private\n          )::text\n      );\n  END;\nEND;\n"
  },
  {
    "schemaname": "public",
    "functionname": "update_post_stats",
    "definition": "\r\nBEGIN\r\n    IF TG_OP = 'INSERT' THEN\r\n        IF NEW.target_type = 'post' THEN\r\n            UPDATE posts \r\n            SET stats = jsonb_set(stats, '{likes}', ((stats->>'likes')::int + 1)::text::jsonb)\r\n            WHERE id = NEW.target_id;\r\n        END IF;\r\n        RETURN NEW;\r\n    ELSIF TG_OP = 'DELETE' THEN\r\n        IF OLD.target_type = 'post' THEN\r\n            UPDATE posts \r\n            SET stats = jsonb_set(stats, '{likes}', GREATEST(((stats->>'likes')::int - 1), 0)::text::jsonb)\r\n            WHERE id = OLD.target_id;\r\n        END IF;\r\n        RETURN OLD;\r\n    END IF;\r\n    RETURN NULL;\r\nEND;\r\n"
  },
  {
    "schemaname": "public",
    "functionname": "update_comment_stats",
    "definition": "\r\nBEGIN\r\n    IF TG_OP = 'INSERT' THEN\r\n        UPDATE posts \r\n        SET stats = jsonb_set(stats, '{comments}', ((stats->>'comments')::int + 1)::text::jsonb)\r\n        WHERE id = NEW.post_id;\r\n        RETURN NEW;\r\n    ELSIF TG_OP = 'DELETE' THEN\r\n        UPDATE posts \r\n        SET stats = jsonb_set(stats, '{comments}', GREATEST(((stats->>'comments')::int - 1), 0)::text::jsonb)\r\n        WHERE id = OLD.post_id;\r\n        RETURN OLD;\r\n    END IF;\r\n    RETURN NULL;\r\nEND;\r\n"
  },
  {
    "schemaname": "public",
    "functionname": "update_user_stats",
    "definition": "\r\nBEGIN\r\n    IF TG_OP = 'INSERT' THEN\r\n        -- Atualizar posts count\r\n        IF TG_TABLE_NAME = 'posts' THEN\r\n            UPDATE users \r\n            SET stats = jsonb_set(stats, '{posts}', ((stats->>'posts')::int + 1)::text::jsonb)\r\n            WHERE id = NEW.user_id;\r\n        END IF;\r\n        \r\n        -- Atualizar followers count\r\n        IF TG_TABLE_NAME = 'follows' THEN\r\n            UPDATE users \r\n            SET stats = jsonb_set(stats, '{followers}', ((stats->>'followers')::int + 1)::text::jsonb)\r\n            WHERE id = NEW.following_id;\r\n            \r\n            UPDATE users \r\n            SET stats = jsonb_set(stats, '{following}', ((stats->>'following')::int + 1)::text::jsonb)\r\n            WHERE id = NEW.follower_id;\r\n        END IF;\r\n        \r\n        RETURN NEW;\r\n    ELSIF TG_OP = 'DELETE' THEN\r\n        -- Atualizar posts count\r\n        IF TG_TABLE_NAME = 'posts' THEN\r\n            UPDATE users \r\n            SET stats = jsonb_set(stats, '{posts}', GREATEST(((stats->>'posts')::int - 1), 0)::text::jsonb)\r\n            WHERE id = OLD.user_id;\r\n        END IF;\r\n        \r\n        -- Atualizar followers count\r\n        IF TG_TABLE_NAME = 'follows' THEN\r\n            UPDATE users \r\n            SET stats = jsonb_set(stats, '{followers}', GREATEST(((stats->>'followers')::int - 1), 0)::text::jsonb)\r\n            WHERE id = OLD.following_id;\r\n            \r\n            UPDATE users \r\n            SET stats = jsonb_set(stats, '{following}', GREATEST(((stats->>'following')::int - 1), 0)::text::jsonb)\r\n            WHERE id = OLD.follower_id;\r\n        END IF;\r\n        \r\n        RETURN OLD;\r\n    END IF;\r\n    RETURN NULL;\r\nEND;\r\n"
  },
  {
    "schemaname": "public",
    "functionname": "create_notification",
    "definition": "\r\nBEGIN\r\n    -- Notificação de like\r\n    IF TG_TABLE_NAME = 'likes' AND TG_OP = 'INSERT' THEN\r\n        IF NEW.target_type = 'post' THEN\r\n            INSERT INTO notifications (user_id, type, title, content, data)\r\n            SELECT p.user_id, 'like', \r\n                   u.name || ' curtiu seu post',\r\n                   'Seu post recebeu uma nova curtida',\r\n                   jsonb_build_object('post_id', NEW.target_id, 'user_id', NEW.user_id)\r\n            FROM posts p, users u\r\n            WHERE p.id = NEW.target_id AND u.id = NEW.user_id AND p.user_id != NEW.user_id;\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- Notificação de comentário\r\n    IF TG_TABLE_NAME = 'comments' AND TG_OP = 'INSERT' THEN\r\n        INSERT INTO notifications (user_id, type, title, content, data)\r\n        SELECT p.user_id, 'comment',\r\n               u.name || ' comentou em seu post',\r\n               LEFT(NEW.content, 100),\r\n               jsonb_build_object('post_id', NEW.post_id, 'comment_id', NEW.id, 'user_id', NEW.user_id)\r\n        FROM posts p, users u\r\n        WHERE p.id = NEW.post_id AND u.id = NEW.user_id AND p.user_id != NEW.user_id;\r\n    END IF;\r\n    \r\n    -- Notificação de follow\r\n    IF TG_TABLE_NAME = 'follows' AND TG_OP = 'INSERT' THEN\r\n        INSERT INTO notifications (user_id, type, title, content, data)\r\n        SELECT NEW.following_id, 'follow',\r\n               u.name || ' começou a seguir você',\r\n               'Você tem um novo seguidor',\r\n               jsonb_build_object('user_id', NEW.follower_id)\r\n        FROM users u\r\n        WHERE u.id = NEW.follower_id;\r\n    END IF;\r\n    \r\n    RETURN COALESCE(NEW, OLD);\r\nEND;\r\n"
  },
  {
    "schemaname": "public",
    "functionname": "update_updated_at_column",
    "definition": "\r\nBEGIN\r\n    NEW.updated_at = NOW();\r\n    RETURN NEW;\r\nEND;\r\n"
  },
  {
    "schemaname": "public",
    "functionname": "search_users",
    "definition": "\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT \r\n        u.id, u.username, u.name, u.bio, u.avatar_url, u.location, u.age, \r\n        u.interests, u.is_premium, u.stats, u.last_seen\r\n    FROM users u\r\n    WHERE \r\n        u.is_active = true\r\n        AND (search_query = '' OR \r\n             u.name ILIKE '%' || search_query || '%' OR \r\n             u.username ILIKE '%' || search_query || '%' OR\r\n             u.bio ILIKE '%' || search_query || '%')\r\n        AND (location_filter = '' OR u.location ILIKE '%' || location_filter || '%')\r\n        AND (u.age BETWEEN age_min AND age_max)\r\n        AND (array_length(interests_filter, 1) IS NULL OR u.interests && interests_filter)\r\n        AND (NOT premium_only OR u.is_premium = true)\r\n    ORDER BY \r\n        CASE WHEN u.is_premium THEN 0 ELSE 1 END,\r\n        u.last_seen DESC\r\n    LIMIT limit_count OFFSET offset_count;\r\nEND;\r\n"
  },
  {
    "schemaname": "public",
    "functionname": "search_posts",
    "definition": "\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT \r\n        p.id, p.user_id, p.content, p.media_urls, p.hashtags, p.stats, p.created_at,\r\n        u.name, u.username, u.avatar_url, u.is_premium\r\n    FROM posts p\r\n    JOIN users u ON p.user_id = u.id\r\n    WHERE \r\n        p.visibility = 'public'\r\n        AND u.is_active = true\r\n        AND (search_query = '' OR p.content ILIKE '%' || search_query || '%')\r\n        AND (array_length(hashtags_filter, 1) IS NULL OR p.hashtags && hashtags_filter)\r\n        AND (user_id_filter IS NULL OR p.user_id = user_id_filter)\r\n    ORDER BY p.created_at DESC\r\n    LIMIT limit_count OFFSET offset_count;\r\nEND;\r\n"
  },
  {
    "schemaname": "public",
    "functionname": "update_subscription_status",
    "definition": "\r\nBEGIN\r\n  UPDATE users \r\n  SET \r\n    status_assinatura = new_status,\r\n    mp_subscription_id = COALESCE(subscription_id, mp_subscription_id),\r\n    mp_customer_id = COALESCE(customer_id, mp_customer_id),\r\n    updated_at = NOW()\r\n  WHERE email = user_email;\r\nEND;\r\n"
  },
  {
    "schemaname": "public",
    "functionname": "register_payment",
    "definition": "\r\nBEGIN\r\n  UPDATE users \r\n  SET \r\n    ultimo_pagamento = payment_date,\r\n    proximo_pagamento = COALESCE(next_payment_date, proximo_pagamento),\r\n    updated_at = NOW()\r\n  WHERE email = user_email;\r\nEND;\r\n"
  },
  {
    "schemaname": "public",
    "functionname": "update_user_plan",
    "definition": "\r\nBEGIN\r\n  UPDATE users \r\n  SET \r\n    plano = new_plan,\r\n    mp_subscription_id = COALESCE(subscription_id, mp_subscription_id),\r\n    updated_at = NOW()\r\n  WHERE email = user_email;\r\nEND;\r\n"
  },
  {
    "schemaname": "auth",
    "functionname": "jwt",
    "definition": "\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n"
  },
  {
    "schemaname": "public",
    "functionname": "handle_new_user",
    "definition": "\r\nBEGIN\r\n  INSERT INTO public.users (id, email, username, full_name, created_at, updated_at)\r\n  VALUES (\r\n    new.id,\r\n    new.email,\r\n    COALESCE(new.raw_user_meta_data->>'username', 'user_' || substr(new.id::text, 1, 8)),\r\n    COALESCE(new.raw_user_meta_data->>'full_name', 'Usuário'),\r\n    now(),\r\n    now()\r\n  );\r\n  RETURN new;\r\nEND;\r\n"
  },
  {
    "schemaname": "public",
    "functionname": "is_email_confirmed",
    "definition": "\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1 FROM auth.users \r\n    WHERE id = user_id AND email_confirmed_at IS NOT NULL\r\n  );\r\nEND;\r\n"
  },
  {
    "schemaname": "public",
    "functionname": "get_authenticated_user",
    "definition": "\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT \r\n    u.id,\r\n    u.email,\r\n    u.username,\r\n    u.full_name,\r\n    u.avatar_url,\r\n    u.bio,\r\n    u.interests,\r\n    u.created_at,\r\n    u.updated_at\r\n  FROM public.users u\r\n  WHERE u.id = auth.uid();\r\nEND;\r\n"
  }
]